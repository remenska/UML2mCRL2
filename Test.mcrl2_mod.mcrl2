act action_1, action_2, action_3;
% P must be followed by S before R happens
proc TestMe = action_1.action_2;



% created: 2014-09-29 20:05:22.553

%====== MONITOR PART GENERATED ==============
% Original formula:[true*. Q . (! ( P || R ))*. R ] false
% ============================
% Modified formula:([true+][Q]([(! (P||R))+][R]false && [R]false )&& [Q]([(! (P||R))+][R]false && [R]false ))
% ============================
act error ;
sort Action = struct action_3_mon
 | action_2_mon
 | action_1_mon;

act action_3_mon,action_3_found;
act action_2_mon,action_2_found;
act action_1_mon,action_1_found;

sort ActionFormula = struct action(act1:Action)
| and(phi1:ActionFormula,phi2:ActionFormula) 
| or(phi1:ActionFormula,phi2:ActionFormula)  
| not(ActionFormula) 
| True 
| False ; 

map satisfy: Action # ActionFormula -> Bool;
var c1,c2:Action;
f,g:ActionFormula;
eqn
	 satisfy(c1,action(c2)) = (c1 == c2) ;	 
	 satisfy(c1,and(f,g)) = satisfy(c1,f) && satisfy(c1,g);
	 satisfy(c1,not(f)) = !satisfy(c1,f);
	 satisfy(c1,or(f,g)) = satisfy(c1,f) || satisfy(c1,g);
	 satisfy(c1,True) = true;
	 satisfy(c1,False) = false;

proc Monitor = Mon_"([true+][Q]([(!(P||R))+][R]false&&[R]false)&&[Q]([(!(P||R))+][R]false&&[R]false))"; 

proc Mon_"([true+][Q]([(!(P||R))+][R]false&&[R]false)&&[Q]([(!(P||R))+][R]false&&[R]false))" = Mon_"[true+][Q]([(!(P||R))+][R]false&&[R]false)&&[Q]([(!(P||R))+][R]false&&[R]false)";  % just removing backets

proc Mon_"[true+][Q]([(!(P||R))+][R]false&&[R]false)&&[Q]([(!(P||R))+][R]false&&[R]false)" = Mon_"[true+][Q]([(!(P||R))+][R]false&&[R]false)" + Mon_"[Q]([(!(P||R))+][R]false&&[R]false)";

proc Mon_"[true+][Q]([(!(P||R))+][R]false&&[R]false)" = Mon_"true+" . Mon_"[Q]([(!(P||R))+][R]false&&[R]false)";

proc Mon_"true+" = Mon_"true". Mon_"true+" + Mon_"true";

proc Mon_"true" = (satisfy(action_3_mon, True)) -> action_3_mon
 + (satisfy(action_2_mon, True)) -> action_2_mon
 + (satisfy(action_1_mon, True)) -> action_1_mon
;

proc Mon_"[Q]([(!(P||R))+][R]false&&[R]false)" = Mon_"Q" . Mon_"([(!(P||R))+][R]false&&[R]false)";

proc Mon_"Q" = (satisfy(action_3_mon, action(Q_mon))) -> action_3_mon
 + (satisfy(action_2_mon, action(Q_mon))) -> action_2_mon
 + (satisfy(action_1_mon, action(Q_mon))) -> action_1_mon
;

proc Mon_"([(!(P||R))+][R]false&&[R]false)" = Mon_"[(!(P||R))+][R]false&&[R]false";  % just removing backets

proc Mon_"[(!(P||R))+][R]false&&[R]false" = Mon_"[(!(P||R))+][R]false" + Mon_"[R]false";

proc Mon_"[(!(P||R))+][R]false" = Mon_"(!(P||R))+" . Mon_"[R]false";

proc Mon_"(!(P||R))+" = Mon_"(!(P||R))". Mon_"(!(P||R))+" + Mon_"(!(P||R))";

proc Mon_"(!(P||R))" = Mon_"!(P||R)";% just removing backets

proc Mon_"!(P||R)" = (satisfy(action_3_mon, not(or(action(P_mon) , action(R_mon))))) -> action_3_mon
 + (satisfy(action_2_mon, not(or(action(P_mon) , action(R_mon))))) -> action_2_mon
 + (satisfy(action_1_mon, not(or(action(P_mon) , action(R_mon))))) -> action_1_mon
;

proc Mon_"[R]false" = Mon_"R" . Mon_"false";

proc Mon_"R" = (satisfy(action_3_mon, action(R_mon))) -> action_3_mon
 + (satisfy(action_2_mon, action(R_mon))) -> action_2_mon
 + (satisfy(action_1_mon, action(R_mon))) -> action_1_mon
;

proc Mon_"false" = error;

init allow({error,action_3_found,
action_2_found,
action_1_found}, 
 comm({	 action_3 | action_3_mon -> action_3_found
,
	 action_2 | action_2_mon -> action_2_found
,
	 action_1 | action_1_mon -> action_1_found

},
 Monitor  || TestMe));